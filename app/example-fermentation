import * as THREE from 'three';

// Enhanced biochemical constants based on real yeast fermentation data
const CONSTANTS = {
  MONOD_KS: 2.0, // Substrate half-saturation constant (g/L)
  MAINTENANCE_COEFFICIENT: 0.05, // Energy required for cell maintenance (g/g/h)
  YIELD_COEFFICIENT: 0.485, // Theoretical max yield (g ethanol/g glucose)
  DEATH_RATE: 0.01, // Cell death rate constant (h^-1)
  MAX_GROWTH_RATE: 0.3, // Maximum specific growth rate (h^-1)
  MAX_ETHANOL_TOLERANCE: 150, // Maximum ethanol tolerance (g/L)
  OPTIMAL_TEMP: 30, // Optimal temperature (°C)
  OPTIMAL_PH: 5.0, // Optimal pH
  GLUCOSE_MOLAR_MASS: 180.16, // g/mol
  ETHANOL_MOLAR_MASS: 46.07, // g/mol
  CO2_MOLAR_MASS: 44.01, // g/mol
  O2_SOLUBILITY: 0.008, // g/L at 30°C
  SUBSTRATE_INHIBITION: 150, // g/L
};

// Color schemes based on real fermentation stages
const COLORS = {
  INITIAL_WORT: new THREE.Color(0xf4d03f), // Golden yellow
  ACTIVE_FERMENTATION: new THREE.Color(0xe67e22), // Dark amber
  FINAL_BEER: new THREE.Color(0xc0392b), // Deep amber-brown
  YEAST_CELLS: new THREE.Color(0xecf0f1), // Off-white
  DEAD_YEAST: new THREE.Color(0x95a5a6), // Grey
  CO2_BUBBLES: new THREE.Color(0xffffff), // White with transparency
  FOAM: new THREE.Color(0xfdfefe), // Creamy white
};

function Fermentation({ scene, parameters, results }) {
    // Create fermentation vessel (keeping existing code...)
    const fermenterGroup = new THREE.Group();
    
    // Enhanced tank material for more realistic appearance
    const tankMaterial = new THREE.MeshPhysicalMaterial({
      color: 0x316b83,
      metalness: 0.8,
      roughness: 0.2,
      transparent: true,
      opacity: 0.85,
      thickness: 0.5,
      transmission: 0.2,
      clearcoat: 1.0,
      envMapIntensity: 1.5,
      ior: 1.5
    });  
    
    // Add foam layer system
    class FoamSystem {
      constructor() {
        this.geometry = new THREE.PlaneGeometry(1.9, 1.9);
        this.material = new THREE.MeshPhysicalMaterial({
          color: COLORS.FOAM,
          transparent: true,
          opacity: 0.8,
          roughness: 0.3,
          metalness: 0,
          transmission: 0.1
        });
        this.mesh = new THREE.Mesh(this.geometry, this.material);
        this.mesh.rotation.x = -Math.PI / 2;
        this.height = 0;
        fermenterGroup.add(this.mesh);
      }

      update(fermentationRate, co2Production) {
        this.height = Math.min(1.2, 0.2 + fermentationRate * 0.5);
        this.mesh.position.y = this.height;
        this.material.opacity = 0.4 + fermentationRate * 0.4;
      }
    }

    // Enhanced biological state tracking
    class FermentationState {
      constructor(initialParameters) {
        this.biomass = 1.0; // g/L
        this.substrate = initialParameters.sugarConcentration; // g/L
        this.ethanol = 0; // g/L
        this.co2 = 0; // g/L
        this.dissolvedO2 = CONSTANTS.O2_SOLUBILITY; // g/L
        this.temperature = initialParameters.temperature; // °C
        this.pH = initialParameters.pH;
        this.time = 0; // hours
        this.foamHeight = 0; // meters
        this.viscosity = 0.001; // Pa·s
        this.deadCells = 0; // g/L
      }

      calculateGrowthRate() {
        const tempEffect = Math.exp(-(Math.pow(this.temperature - CONSTANTS.OPTIMAL_TEMP, 2) / 100));
        const phEffect = Math.exp(-(Math.pow(this.pH - CONSTANTS.OPTIMAL_PH, 2) / 2));
        const substrateEffect = this.substrate / (CONSTANTS.MONOD_KS + this.substrate);
        const ethanolInhibition = Math.max(0, 1 - (this.ethanol / CONSTANTS.MAX_ETHANOL_TOLERANCE));
        const o2Effect = this.dissolvedO2 / (CONSTANTS.O2_SOLUBILITY + this.dissolvedO2);
        
        return CONSTANTS.MAX_GROWTH_RATE * substrateEffect * tempEffect * phEffect * ethanolInhibition * o2Effect;
      }

      update(deltaTime) {
        const μ = this.calculateGrowthRate();
        
        // Substrate consumption
        const substrateConsumption = (μ * this.biomass / CONSTANTS.YIELD_COEFFICIENT) * deltaTime;
        this.substrate = Math.max(0, this.substrate - substrateConsumption);
        
        // Biomass growth and death
        const growth = μ * this.biomass * deltaTime;
        const death = CONSTANTS.DEATH_RATE * this.biomass * deltaTime;
        this.biomass = Math.max(0, this.biomass + growth - death);
        this.deadCells += death;
        
        // Product formation (ethanol and CO2)
        const ethanolProduction = substrateConsumption * 0.48; // Stoichiometric conversion
        this.ethanol += ethanolProduction;
        this.co2 += ethanolProduction * (CONSTANTS.CO2_MOLAR_MASS / CONSTANTS.ETHANOL_MOLAR_MASS);
        
        // Oxygen consumption
        this.dissolvedO2 = Math.max(0, this.dissolvedO2 - (0.1 * μ * this.biomass * deltaTime));
        
        // Update viscosity based on biomass and dead cells
        this.viscosity = 0.001 * Math.exp(0.15 * (this.biomass + this.deadCells));
        
        this.time += deltaTime;
        
        return {
          growthRate: μ,
          co2ProductionRate: ethanolProduction * (CONSTANTS.CO2_MOLAR_MASS / CONSTANTS.ETHANOL_MOLAR_MASS) / deltaTime
        };
      }
    }

    // Initialize systems
    const fermentationState = new FermentationState(parameters);
    const foamSystem = new FoamSystem();
    
    // Enhanced particle behavior
    class EnhancedParticle extends THREE.Object3D {
      constructor(type, state) {
        super();
        this.type = type;
        this.state = state;
        this.age = 0;
        this.active = true;
        this.velocity = new THREE.Vector3();
        
        const geometry = this.createGeometry();
        const material = this.createMaterial();
        this.mesh = new THREE.Mesh(geometry, material);
        this.add(this.mesh);
        
        this.resetPosition();
      }

      createGeometry() {
        switch(this.type) {
          case 'bubble':
            return new THREE.SphereGeometry(0.02 + Math.random() * 0.01, 8, 8);
          case 'yeast':
            // Elongated shape for yeast cells
            return new THREE.SphereGeometry(0.015 + Math.random() * 0.005, 8, 8);
          case 'substrate':
            return new THREE.BoxGeometry(0.01, 0.01, 0.01);
          default:
            return new THREE.SphereGeometry(0.01, 8, 8);
        }
      }

      createMaterial() {
        switch(this.type) {
          case 'bubble':
            return new THREE.MeshPhysicalMaterial({
              color: COLORS.CO2_BUBBLES,
              transparent: true,
              opacity: 0.3,
              transmission: 0.9,
              thickness: 0.5,
              roughness: 0.1
            });
          case 'yeast':
            return new THREE.MeshPhysicalMaterial({
              color: this.age > 48 ? COLORS.DEAD_YEAST : COLORS.YEAST_CELLS,
              transparent: true,
              opacity: 0.8,
              roughness: 0.4
            });
          case 'substrate':
            return new THREE.MeshPhysicalMaterial({
              color: COLORS.INITIAL_WORT,
              transparent: true,
              opacity: 0.6
            });
        }
      }

      update(deltaTime) {
        this.age += deltaTime;
        
        // Calculate forces based on particle type and fermentation state
        const buoyancy = this.calculateBuoyancy();
        const brownian = this.calculateBrownianMotion();
        const convection = this.calculateConvection();
        
        this.velocity.add(buoyancy).add(brownian).add(convection);
        this.velocity.multiplyScalar(1 - this.state.viscosity);
        
        this.position.add(this.velocity);
        
        // Check boundaries and reset if needed
        if (this.isOutOfBounds()) {
          this.resetPosition();
        }
        
        // Update appearance
        if (this.type === 'yeast') {
          this.updateYeastAppearance();
        }
      }

      calculateBuoyancy() {
        const force = new THREE.Vector3();
        if (this.type === 'bubble') {
          force.y = 0.01 / this.state.viscosity;
        }
        return force;
      }

      calculateBrownianMotion() {
        const temperature = this.state.temperature;
        const scale = Math.sqrt(temperature / 303.15) * 0.001;
        return new THREE.Vector3(
          (Math.random() - 0.5) * scale,
          (Math.random() - 0.5) * scale,
          (Math.random() - 0.5) * scale
        );
      }

      calculateConvection() {
        // Simplified convection based on temperature gradient
        const force = new THREE.Vector3();
        const distanceFromCenter = Math.sqrt(
          this.position.x * this.position.x + this.position.z * this.position.z
        );
        const angle = Math.atan2(this.position.z, this.position.x);
        force.x = Math.cos(angle) * 0.001 * (1 - distanceFromCenter);
        force.z = Math.sin(angle) * 0.001 * (1 - distanceFromCenter);
        return force;
      }

      updateYeastAppearance() {
        if (this.age > 48 && this.mesh.material.color !== COLORS.DEAD_YEAST) {
          this.mesh.material.color.copy(COLORS.DEAD_YEAST);
          this.mesh.material.opacity = 0.6;
        }
      }

      resetPosition() {
        const radius = Math.random() * 0.9;
        const theta = Math.random() * Math.PI * 2;
        this.position.set(
          Math.cos(theta) * radius,
          -1.2 + Math.random() * 2.4,
          Math.sin(theta) * radius
        );
        this.velocity.set(0, 0, 0);
      }

      isOutOfBounds() {
        const pos = this.position;
        const r = Math.sqrt(pos.x * pos.x + pos.z * pos.z);
        return r > 0.95 || Math.abs(pos.y) > 1.2;
      }
    }

    // Create particle systems
    const particles = {
      bubbles: Array(300).fill().map(() => new EnhancedParticle('bubble', fermentationState)),
      yeast: Array(200).fill().map(() => new EnhancedParticle('yeast', fermentationState)),
      substrate: Array(150).fill().map(() => new EnhancedParticle('substrate', fermentationState))
    };

    // Add particles to scene
    Object.values(particles).flat().forEach(particle => fermenterGroup.add(particle));

    // Define impeller group
const impellerGeometry = new THREE.BoxGeometry(0.5, 0.5, 0.5); // Example geometry
const impellerMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
const impeller = new THREE.Mesh(impellerGeometry, impellerMaterial);
const impellerGroup = new THREE.Group();
impellerGroup.add(impeller);
scene.add(impellerGroup);

    // Main animation loop
    function animate() {
      const deltaTime = 1/60; // Convert to hours
      
      // Update fermentation state
      const { growthRate, co2ProductionRate } = fermentationState.update(deltaTime);
      
      /// Define particle system for liquid
const particleCount = 10000;
const particles = new THREE.BufferGeometry();
const positions = new Float32Array(particleCount * 3);

for (let i = 0; i < particleCount; i++) {
  positions[i * 3] = Math.random() * 10 - 5; // x
  positions[i * 3 + 1] = Math.random() * 10 - 5; // y
  positions[i * 3 + 2] = Math.random() * 10 - 5; // z
}

particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));

const particleMaterial = new THREE.PointsMaterial({
  color: COLORS.INITIAL_WORT,
  size: 0.1,
  transparent: true,
  opacity: 0.8,
});

const liquid = new THREE.Points(particles, particleMaterial);
scene.add(liquid);

// Update foam system
foamSystem.update(growthRate, co2ProductionRate);

// Update liquid appearance
liquid.material.color.lerpColors(
  COLORS.INITIAL_WORT,
  COLORS.FINAL_BEER,
  fermentationState.ethanol / CONSTANTS.MAX_ETHANOL_TOLERANCE
);

// Update liquid turbidity based on biomass
liquid.material.opacity = Math.max(0.4, 0.8 - fermentationState.biomass * 0.05);

// Update particle positions to simulate liquid movement
const positionsArray = liquid.geometry.attributes.position.array;
for (let i = 0; i < particleCount; i++) {
  positionsArray[i * 3 + 1] -= 0.01; // Simulate gravity effect
  if (positionsArray[i * 3 + 1] < -5) {
    positionsArray[i * 3 + 1] = 5; // Reset particle position
  }
}
liquid.geometry.attributes.position.needsUpdate = true;

// Update impeller rotation based on temperature and viscosity
const rotationSpeed = 0.1 * (fermentationState.temperature / 30) * (1 / fermentationState.viscosity);
impellerGroup.rotation.y += rotationSpeed;
      
      // Update particles
      Object.values(particles).flat().forEach(particle => particle.update(deltaTime));
      
      // Rotate fermenter slightly
      fermenterGroup.rotation.y += 0.001;
      
      // Update results object if provided
      if (results) {
        Object.assign(results, {
          biomass: fermentationState.biomass,
          substrate: fermentationState.substrate,
          ethanol: fermentationState.ethanol,
          co2: fermentationState.co2,
          pH: fermentationState.pH,
          temperature: fermentationState.temperature,
          dissolvedO2: fermentationState.dissolvedO2,
          growthRate,
          co2ProductionRate,
          time: fermentationState.time
        });
      }
    }

    return animate;
}

export { Fermentation };